initSidebarItems({"constant":[["LL_PATH",""],["OPTION_PATH",""],["RESULT_PATH",""],["STRING_PATH",""],["VEC_PATH",""]],"fn":[["expr_block","Like snippet_block, but add braces if the expr is not an ExprBlock"],["get_parent_expr","get a parent expr if any â€“ this is useful to constrain a lint"],["in_external_macro","invokes in_macro with the expansion info of the given span slightly heavy, try to use this after other checks have already happened"],["in_macro","returns true if the macro that expanded the crate was outside of the current crate or was a compiler plugin"],["match_def_path","check if a DefId's path matches the given absolute type path usage e.g. with `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`"],["match_path","match a Path against a slice of segment string literals, e.g. `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`"],["match_trait_method","check if method call given in \"expr\" belongs to given trait"],["match_type","check if type is struct or enum type with given def path"],["snippet","convert a span to a code snippet if available, otherwise use default, e.g. `snippet(cx, expr.span, \"..\")`"],["snippet_block","convert a span (from a block) to a code snippet if available, otherwise use default, e.g. `snippet(cx, expr.span, \"..\")` This trims the code of indentation, except for the first line Use it for blocks or block-like things which need to be printed as such"],["span_help_and_lint",""],["span_lint",""],["span_note_and_lint",""],["trim_multiline","Trim indentation from a multiline string with possibility of ignoring the first line"],["walk_ptrs_ty","return the base type for references and raw pointers"],["walk_ptrs_ty_depth","return the base type for references and raw pointers, and count reference depth"]]});